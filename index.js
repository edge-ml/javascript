async function loadFetch() {
  if (typeof fetch == "undefined") {
    // Case Node.js
    const node_fetch = await import("node-fetch");
    globalThis.fetch = node_fetch.default;
  }
  // Case Browser
  return;
}

async function postData(url, body) {
  await loadFetch();
  var res = undefined;
  try {
    const data = await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });
    const txt = JSON.parse(await data.text());
    res = { status: data.status, text: txt };
  } catch (err) {
    if (!err.text) {
      // Server error
      res = { text: { error: "Server Error" } };
    } else {
      const txt = JSON.parse(await err.text());
      res = { status: err.status, text: txt };
    }
  }
  if (checkStatus(res.status)) {
    return res;
  }
  throw res;
}

const URLS = {
  uploadDataset: "/api/deviceapi/uploadDataset",
  initDatasetIncrement: "/api/deviceapi/initDatasetIncrement",
  addDatasetIncrement: "/api/deviceapi/addDatasetIncrement",
  addDatasetIncrementBatch: "/api/deviceapi/addDatasetIncrementBatch",
};

function checkStatus(status) {
  return status >= 200 && status < 300;
}

/**
 * Uploads a whole dataset to a specific project
 * @param {string} url - The url of the backend server
 * @param {string} key - The Device-Api-Key
 * @param {object} dataset - The dataset to upload
 * @returns A Promise indicating success or failure
 */
async function sendDataset(url, key, dataset) {
  const res = await postData(url + URLS.uploadDataset, {
    key: key,
    payload: dataset,
  });
  return res.text.message;
}

/**
 *
 * @param {string} url - The url of the backend server
 * @param {string} key - The Device-Api-Key
 * @param {boolean} useDeviceTime - True if you want to use timestamps generated by the server
 * @returns Function to upload single datapoints to one dataset inside a specific project
 */
async function datasetCollector(url, key, name, useDeviceTime) {
  try {
    const data = await postData(url + URLS.initDatasetIncrement, {
      deviceApiKey: key,
      name: name,
    });

    if (!data || !data.text || !data.text.datasetKey) {
      throw new Error("Could not generate datasetCollector");
    }
    const datasetKey = data.text.datasetKey;

    var dataStore = { datasetKey: datasetKey, data: [] };
    var counter = 0;
    var error = undefined;

    /**
     * Uploads a vlaue for a specific timestamp to a datasets timeSeries with name sensorName
     * @param {string} sensorName - The name of the timeSeries to upload the value to
     * @param {number} value - The datapoint to upload
     * @param {number} time - The timestamp assigned to the datapoint
     * @returns A Promise indicating success or failure of upload
     */
    function addDataPoint(time, sensorName, value) {
      if (error) {
        throw new Error(error);
      }
      if (typeof value !== "number") {
        throw new Error("Datapoint is not a number");
      }
      if (!useDeviceTime && typeof time !== "number") {
        throw new Error("Provide a valid timestamp");
      }

      if (useDeviceTime) {
        time = new Date().getTime();
      }

      if (dataStore.data.every((elm) => elm.sensorname !== sensorName)) {
        dataStore.data.push({
          sensorname: sensorName,
          start: time,
          end: time,
          timeSeriesData: [{ timestamp: time, datapoint: value }],
        });
      } else {
        const idx = dataStore.data.findIndex(
          (elm) => elm.sensorname === sensorName
        );
        dataStore.data[idx].timeSeriesData.push({
          timestamp: time,
          datapoint: value,
        });

        if (dataStore.data[idx].start > time) {
          dataStore.data[idx].start = time;
        }
        if (dataStore.data[idx].end < time) {
          dataStore.data[idx].end = time;
        }
      }

      counter++;
      if (counter > 500) {
        upload();
        counter = 0;
        dataStore = { datasetKey: datasetKey, data: [] };
      }
    }

    function upload() {
      const tmp_datastore = JSON.parse(JSON.stringify(dataStore));
      postData(url + URLS.addDatasetIncrementBatch, tmp_datastore)
        .then()
        .catch(() => {
          error = "Could not upload data";
        });
    }

    /**
     * Synchronizes the server with the data when you have added all data
     */
    async function onComplete() {
      await upload();
      if (error) {
        throw new Error(error);
      }
    }

    if (useDeviceTime) {
      return {
        addDataPoint: (sensorName, value) =>
          addDataPoint(undefined, sensorName, value),
        onComplete: onComplete,
      };
    } else {
      return {
        addDataPoint: (time, sensorName, value) =>
          addDataPoint(time, sensorName, value),
        onComplete: onComplete,
      };
    }
  } catch (e) {
    throw e;
  }
}

if (typeof window === "undefined") {
  module.exports = { datasetCollector, sendDataset };
}
