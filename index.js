const axios = require("axios");

const URLS = {
  uploadDataset: "/api/deviceapi/uploadDataset",
  initDatasetIncrement: "/api/deviceapi/initDatasetIncrement",
  addDatasetIncrement: "/api/deviceapi/addDatasetIncrement",
  addDatasetIncrementBatch: "/api/deviceapi/addDatasetIncrementBatchs",
};

axios.interceptors.response.use(
  (response) => {
    if (response.status === 401) {
      alert("You are not authorized");
    }
    return response;
  },
  (error) => {
    if (error.response && error.response.data) {
      return Promise.reject(error.response.data.error);
    }
    return Promise.reject(error.message);
  }
);

/**
 * Uploads a whole dataset to a specific project
 * @param {string} url - The url of the backend server
 * @param {string} key - The Device-Api-Key
 * @param {object} dataset - The dataset to upload
 * @returns A Promise indicating success or failure
 */
exports.sendDataset = function (url, key, dataset) {
  return new Promise((resolve, reject) => {
    return axios
      .post(url + URLS.uploadDataset, { key: key, payload: dataset })
      .then((data) => resolve(data.data.message))
      .catch((err) => {
        if (!err) {
          reject("Could not send dataset");
        } else {
          reject(err);
        }
      });
  });
};

/**
 *
 * @param {string} url - The url of the backend server
 * @param {string} key - The Device-Api-Key
 * @param {boolean} useDeviceTime - True if you want to use timestamps generated by the server
 * @returns Function to upload single datapoints to one dataset inside a specific project
 */
exports.datasetCollector = async function (url, key, name, useDeviceTime) {
  try {
    const data = await axios.post(url + URLS.initDatasetIncrement, {
      deviceApiKey: key,
      name: name,
    });
    if (!data || !data.data || !data.data.datasetKey) {
      throw new Error();
    }

    const datasetKey = data.data.datasetKey;

    var dataStore = { datasetKey: datasetKey, data: [] };
    var counter = 0;
    var error = undefined;

    /**
     * Uploads a vlaue for a specific timestamp to a datasets timeSeries with name sensorName
     * @param {string} sensorName - The name of the timeSeries to upload the value to
     * @param {number} value - The datapoint to upload
     * @param {number} time - The timestamp assigned to the datapoint
     * @returns A Promise indicating success or failure of upload
     */
    function addDataPoint(time, sensorName, value) {
      if (error) {
        throw new Error(error);
      }
      if (typeof value !== "number") {
        throw new Error("Datapoint is not a number");
      }
      if (useDeviceTime && typeof time !== "number") {
        throw new Error("Provide a valid timestamp");
      }

      if (useDeviceTime) {
        time = new Date().getTime();
      }

      if (dataStore.data.every((elm) => elm.sensorname !== sensorName)) {
        dataStore.data.push({
          sensorname: sensorName,
          start: time,
          end: time,
          timeSeriesData: [{ timestamp: time, datapoint: value }],
        });
      } else {
        const idx = dataStore.data.findIndex(
          (elm) => elm.sensorname === sensorName
        );
        dataStore.data[idx].timeSeriesData.push({
          timestamp: time,
          datapoint: value,
        });

        if (dataStore.data[idx].start > time) {
          dataStore.data[idx].start = time;
        }
        if (dataStore.data[idx].end < time) {
          dataStore.data[idx].end = time;
        }
      }

      counter++;
      if (counter > 1000) {
        upload();
      }
    }

    function upload() {
      axios
        .post(url + URLS.addDatasetIncrementBatch, dataStore)
        .then()
        .catch(() => {
          error = "Could not upload data";
        });
      counter = 0;
      dataStore = { datasetKey: datasetKey, data: [] };
    }

    /**
     * Syncrhonizes the server with the data when you have added all data
     */
    function onComplete() {
      if (error) {
        throw new Error(error);
      }
      upload();
    }

    if (useDeviceTime) {
      return {
        addDataPoint: (sensorName, value) =>
          addDataPoint(undefined, sensorName, value),
        onComplete: onComplete,
      };
    } else {
      return {
        addDataPoint: (time, sensorName, value) =>
          addDataPoint(time, sensorName, value),
        onComplete: onComplete,
      };
    }
  } catch (e) {
    return { error: e };
  }
};
