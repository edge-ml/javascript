import { Predictor } from './predictor';
import axios from "axios";

axios.interceptors.response.use(
  function (res) {
    return { status: res.status, text: res.data };
  },
  function (error) {
    if (!error.response) {
      return Promise.reject("Server error");
    }
    return Promise.reject(
      error.response.status +
        ": " +
        (error.response.data.error
          ? error.response.data.error
          : error.response.data)
    );
  }
);

const URLS = {
  uploadDataset: "/api/deviceapi/uploadDataset",
  initDatasetIncrement: "/api/deviceapi/initDatasetIncrement",
  addDatasetIncrement: "/api/deviceapi/addDatasetIncrement",
  addDatasetIncrementBatch: "/api/deviceapi/addDatasetIncrementBatch",
};

/**
 * Uploads a whole dataset to a specific project
 * @param {string} url - The url of the backend server
 * @param {string} key - The Device-Api-Key
 * @param {object} dataset - The dataset to upload
 * @returns A Promise indicating success or failure
 */
async function sendDataset(url, key, dataset) {
  const res = await axios.post(url + URLS.uploadDataset, {
    key: key,
    payload: dataset,
  });
  return res.text.message;
}

/**
 *
 * @param {string} url - The url of the backend server
 * @param {string} key - The Device-Api-Key
 * @param {boolean} useDeviceTime - True if you want to use timestamps generated by the server
 * @returns Function to upload single datapoints to one dataset inside a specific project
 */
async function datasetCollector(
  url,
  key,
  name,
  useDeviceTime,
  metaData,
  datasetLabel
) {
  try {
    const data = await axios.post(url + URLS.initDatasetIncrement, {
      deviceApiKey: key,
      name: name,
      metaData: metaData,
    });

    if (!data || !data.text || !data.text.datasetKey) {
      throw new Error("Could not generate datasetCollector");
    }
    const datasetKey = data.text.datasetKey;

    var uploadComplete = false;
    var dataStore = { datasetKey: datasetKey, data: [] };
    var counter = 0;
    var error = undefined;

    /**
     * Uploads a vlaue for a specific timestamp to a datasets timeSeries with name sensorName
     * @param {string} sensorName - The name of the timeSeries to upload the value to
     * @param {number} value - The datapoint to upload
     * @param {number} time - The timestamp assigned to the datapoint
     * @returns A Promise indicating success or failure of upload
     */
    function addDataPoint(time, sensorName, value) {
      if (error) {
        throw new Error(error);
      }
      if (typeof value !== "number") {
        throw new Error("Datapoint is not a number");
      }
      if (!useDeviceTime && typeof time !== "number") {
        throw new Error("Provide a valid timestamp");
      }

      if (useDeviceTime) {
        time = new Date().getTime();
      }

      value = Math.round(value * 100) / 100;

      if (dataStore.data.every((elm) => elm.sensorname !== sensorName)) {
        dataStore.data.push({
          sensorname: sensorName,
          start: time,
          end: time,
          timeSeriesData: [{ timestamp: time, datapoint: value }],
        });
      } else {
        const idx = dataStore.data.findIndex(
          (elm) => elm.sensorname === sensorName
        );
        dataStore.data[idx].timeSeriesData.push({
          timestamp: time,
          datapoint: value,
        });

        if (dataStore.data[idx].start > time) {
          dataStore.data[idx].start = time;
        }
        if (dataStore.data[idx].end < time) {
          dataStore.data[idx].end = time;
        }
      }

      counter++;
      if (counter > 500) {
        upload();
        counter = 0;
        dataStore = { datasetKey: datasetKey, data: [] };
      }
    }

    async function upload(datasetLabel) {
      const tmp_datastore = JSON.parse(JSON.stringify(dataStore));
      try {
        await axios.post(url + URLS.addDatasetIncrementBatch, {
          datasetKey: tmp_datastore.datasetKey,
          data: tmp_datastore.data,
          datasetLabel: datasetLabel,
        });
      } catch (e) {
        error = "Could not upload data";
      }
    }

    /**
     * Synchronizes the server with the data when you have added all data
     */
    async function onComplete() {
      if (uploadComplete) {
        throw new Error("Dataset is already uploaded");
      }
      await upload(datasetLabel);
      if (error) {
        throw new Error(error);
      }
      uploadComplete = true;
    }

    if (useDeviceTime) {
      return {
        addDataPoint: (sensorName, value) =>
          addDataPoint(undefined, sensorName, value),
        onComplete: onComplete,
      };
    } else {
      return {
        addDataPoint: (time, sensorName, value) =>
          addDataPoint(time, sensorName, value),
        onComplete: onComplete,
      };
    }
  } catch (e) {
    throw e;
  }
}

export default { datasetCollector, sendDataset, Predictor };
